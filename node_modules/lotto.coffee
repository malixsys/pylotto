module.exports = class Lotto
  #https://github.com/stagas/chaos
  fs = require('fs')
  crypto  = require('crypto')
  
  constructor: (name='test') ->
    this.use_random(this._true_random)
    @filename = __dirname + "/" + name + ".json"
  
  use_random: (@rnd) ->
  
  pick: (min, max) ->
    @rnd(min, max)
  
  choose: (from, count) ->
    group = []
    group.push(item) for item in from
    chosen = []
    i = 1
    while i <= count
      picked = this.pick(1, group.length)
      chosen.push group[picked-1]
      group.splice picked-1, 1
      i++
    chosen
    
  echo: (cmd) ->
    cmd
  
  newState: (cash = 0) ->
    ret = {}
    ret.total = cash
    ret.players = []
    ret.winners = []
    ret

  clear: (cash = 0) ->
    this.save(this.newState(cash))
    "effacee"
    
  save: (data) ->
    s = JSON.stringify(data)
    fs.writeFileSync(@filename, s);

  load: ->
    s = fs.readFileSync(@filename)
    data = JSON.parse(s)
    data
    
  exec: (commands) ->
    throw "commande invalide" unless commands
    throw "commande invalide" if commands.length is 0
    
    ret = "aucune commande"
    
    switch commands[0].toLowerCase()
      when "ignorer" then ret = "ignoree"
      when "status" then ret = JSON.stringify(this.load())
      when "effacer" then ret = this.clear(170)
      when "echo" then ret = (if commands.length > 1 then commands[1] else "")
      when "achat" then ret = this.achat(if commands.length > 1 then commands[1] else "")
      when "tirage" then ret = this.draw()
      when "gagnants" then ret = this.show_winner_table()
      else throw "'" + commands[0] + "' n'est pas une commande valide"
    ret
  
  ticketPrice: ->
    10
  
  prizes: (value)  ->
    priceValue = value * 0.50
    prizes = []
    prizes.push (priceValue * 0.75)
    prizes.push (priceValue * 0.15)
    prizes.push (priceValue * 0.10)
    prizes

  achat: (name) ->
    data = this.load()
    index = data.players.length
    throw "aucun billet disponible" if index is 50
    data.total += this.ticketPrice()
    data.players.push name
    this.save(data)
    str = "" + data.players[index] + " - boule " + (index + 1)
    str


  column_width: (row, col) ->
    return 0 if row is undefined or row.length <= col
    row[col].length

  largest_row_width: (grid, col) ->
    widths = (this.column_width(row,col) for row in grid)
    i = 0
    max = 0
    while i < widths.length
      w = widths[i]
      max = w if w > max
      i++
    max

  pad: (chr, width, str = '') ->
    ret = '' + str
    i = ret.length
    while i < width
      ret += chr
      i++
    ret

  divider: (widths) ->
    return '---' if widths is undefined or widths.length < 1
    i = 0
    w = 1 #left post
    while i < widths.length
      w += 2
      if widths[i] > 0
        w += widths[i] + 1
      i++
    this.pad('-', w)

  row: (cells, widths) ->
    return '| |' if cells is undefined or cells.length < 1
    throw "cellules et largeurs incompatibles " + cells.length + " vs " +  widths.length + "" unless cells.length is widths.length
    row = '|'
    i = 0
    while i < cells.length
      unless cells[i] is undefined or widths[i] < 1
        row += " "
        row += this.pad(' ', widths[i], cells[i])
      row += " |"
      i++
    row

  table: (rows) ->
    return '---\n---' if rows is undefined or rows.length < 1 or rows[0].length < 1
    n = rows[0].length - 1
    widths = (this.largest_row_width(rows, col) for col in [0..n])
    divider = this.divider(widths)
    ret = divider
    i = 0
    while i < rows.length
      row = this.row(rows[i], widths)
      ret += '\n' + row
      ret += '\n' + divider
      i++
    ret

  draw: (num = 3) ->
    throw "draw(" + num + ") est invalide" if num < 2
    data = this.load()
    numbers = this.choose(data.players, num)
    data.winners = numbers
    this.save(data)
    num + " gagnants choisis"

  show_winner_table: ->
    data = this.load()
    return "Aucun resultat" unless data.winners.length > 0
    prizes = this.prizes(data.total)
    table = []
    table.push ['1ere boule','2eme boule','3eme boule']
    row = []
    i = 0
    while i < data.winners.length
      cell = data.winners[i]
      cell += ' : '
      cell += prizes[i]
      cell += '$'
      row.push cell
      i++
    table.push row
    txt = this.table(table)
    txt

  _true_random: (min, max) ->
    return min if min is max
    unsigned_int = crypto.randomBytes(8).readUInt32LE(0)
    result_range = max - min
    factor = result_range / 4294967295
    ret = Math.round((unsigned_int * factor) + min)
    ret
   

